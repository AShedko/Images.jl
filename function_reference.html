<!DOCTYPE html>
<html>
<head>
  <meta name="author" content="Tim Holy">
  <meta charset="utf-8">
  <title>Function Reference</title>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro:400,700'
        rel='stylesheet' type='text/css'>
  <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/custom.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/hk-pyg.css" rel="stylesheet" type="text/css" media="all">
  <script src="js/jquery-2.0.3.min.js" type="text/javascript"></script>
  <script src="js/bootstrap.min.js" type="text/javascript"></script>
  <script src="js/list.min.js" type="text/javascript"></script>
</head>
<body>
  <div id="topbar" style="z-index: 3">
    <div class="container">
      <div class="row">
        <ul>
          <li><div id="pkgname">Images 0.4.47+</div></li>
          <li><a href="http:&#x2F;&#x2F;github.com&#x2F;timholy&#x2F;Images.jl">Code</a></li>
          <li><a href="http:&#x2F;&#x2F;github.com&#x2F;timholy&#x2F;Images.jl/issues">Issues</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container" style="z-index: auto">
    <div class="row">
      <div class="col-sm-7">
      <div id="body-content">
      <h1>Function Reference</h1>
<p>Below, <code>&#91;&#93;</code> in an argument list means an optional argument.</p>
<h1 id="image-construction">Image construction</h1>
<h2 id="image-type">Image (type)</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">Image&#40;data, &#91;properties&#93;&#41;
Image&#40;data, prop1&#61;val1, prop2&#61;val2, ...&#41;</code></pre>
<p>creates a new direct image. In contrast with <code>convert</code>, <code>grayim</code> and <code>colorim</code>, this does not permute the data array or attempt to guess any of the <code>properties</code>. If <code>data</code> encodes color information along one of the dimensions of the array &#40;as opposed to using a <code>Color</code> array, from the <code>Colors.jl</code> package&#41;, be sure to specify the <code>&quot;colordim&quot;</code> and <code>&quot;colorspace&quot;</code> in <code>properties</code>.</p>
<h2 id="imagecmap">ImageCmap</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">ImageCmap&#40;data, cmap, &#91;properties&#93;&#41;</code></pre>
<p>creates an indexed &#40;colormap&#41; image.</p>
<h2 id="convert">convert</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">convert&#40;Image, A&#41;
convert&#40;Array, img&#41;
convert&#40;Image&#123;HSV&#125;, img&#41;</code></pre>
<p>The first creates a 2d image from an array, setting up default properties. The data array is assumed to be in &quot;vertical-major&quot; order, and an m-by-n-by-3 array will be assumed to encode color along its third dimension.</p>
<p><code>convert&#40;Array, img&#41;</code> works in the opposite direction, permuting dimensions &#40;if needed&#41; to put it in Matlab-standard storage order.</p>
<p>The third syntax allows you to convert from one colorspace to another.</p>
<h2 id="grayim">grayim</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">grayim&#40;A&#41;</code></pre>
<p>creates a 2d or 3d _spatial_ grayscale Image from an AbstractArray, assumed to be in &quot;horizontal-major&quot; order &#40;and without permuting any dimensions&#41;. If you are working with 3d grayscale images, usage of this function is strongly recommended. This can fix errors like one of the following:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">ERROR: Wrong number of spatial dimensions for plain Array, use an AbstractImage type
ERROR: Cannot infer colorspace of Array, use an AbstractImage type
ERROR: Cannot infer pixelspacing of Array, use an AbstractImage type</code></pre>
<p>The main reason for such errors–-and the reason that <code>grayim</code> is recommended–-is the Matlab-derived convention that a <code>m x n x 3</code> array is to be interpreted as RGB.  One might then say that an <code>m x n x k</code> array, for <code>k</code> different from 3, could be interpreted as grayscale. However, this would lead to difficult-to-track-down surprises on the day where <code>k</code> happened to be 3 for your grayscale image. Instead, the approach taken in <code>Images.jl</code> is to throw an error, encouraging users to develop the habit of wrapping their 3d grayscale arrays in an unambiguous <code>Image</code> type.</p>
<h2 id="colorim">colorim</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">colorim&#40;A, &#91;colorspace&#93;&#41;</code></pre>
<p>Creates a 2d color image from an AbstractArray, auto-detecting which of the first or last dimension encodes the color and choosing between &quot;horizontal-&quot; and &quot;vertical-major&quot; accordingly. <code>colorspace</code> defaults to <code>&quot;RGB&quot;</code> but could also be e.g. <code>&quot;Lab&quot;</code> or <code>&quot;HSV&quot;</code>.  If the array represents a 4-channel image, the <code>colorspace</code> option is mandatory since there is no way to automatically distinguish between <code>&quot;ARGB&quot;</code> and <code>&quot;RGBA&quot;</code>.  If both the first and last dimensions happen to be of size 3 or 4, it is impossible to guess which one represents color and thus an error is generated.  Thus, if your code should be robust to arbitrary-sized images, you should use the <code>Image</code> constructor directly.</p>
<h2 id="copyproperties">copyproperties</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">copyproperties&#40;img, data&#41;</code></pre>
<p>Creates a new image from the data array <code>data</code>, copying the properties from image <code>img</code>.</p>
<h2 id="shareproperties">shareproperties</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">shareproperties&#40;img, data&#41;</code></pre>
<p>Creates a new image from the data array <code>data</code>, _sharing_ the properties of image <code>img</code>. Any modifications made to the properties of one will affect the other.</p>
<h2 id="similar">similar</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">similar&#40;img, &#91;type&#93;, &#91;dims&#93;&#41;</code></pre>
<p>Like the standard Julia command, this will create an <code>Image</code> of similar type, copying the properties.</p>
<h2 id="overlay">Overlay</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">Overlay&#40;channels, colors, clim&#41;
Overlay&#40;channels, colors, mapi&#41;</code></pre>
<p>Create an <code>Overlay</code> array from grayscale channels.  <code>channels &#61; &#40;channel1, channel2, ...&#41;</code>, <code>colors</code> is a vector or tuple of <code>Color</code>s, and <code>clim</code> is a vector or tuple of min/max values, e.g., <code>clim &#61; &#40;&#40;min1,max1&#41;,&#40;min2,max2&#41;,...&#41;</code>. Alternatively, you can supply a list of <code>MapInfo</code> objects</p>
<h2 id="overlayimage">OverlayImage</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">OverlayImage&#40;channels, colors, clim&#41;</code></pre>
<p>Like <code>Overlay</code>, except it creates an Image &#40;not just an array&#41;.</p>
<h1 id="accessing-image-data">Accessing image data</h1>
<h2 id="data">data</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">data&#40;img&#41;</code></pre>
<p>returns a reference to the array data in the image. It allows you to use an algorithm written for <code>Array</code>s or <code>AbstractArray</code>s on <code>Image</code> types.  This works for both <code>AbstractImage</code>s and <code>AbstractArray</code>s &#40;for the latter it just returns the input&#41;, so is a &quot;safe&quot; component of any algorithm.</p>
<h2 id="raw">raw</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">raw&#40;img&#41;</code></pre>
<p>returns a reference to the array data in raw storage format. This is particularly useful when Images.jl wraps image data in a <code>FixedPointNumbers</code> type, and raw data access is desired. For example</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">img &#61; imread&#40;&quot;someimage.tif&quot;&#41;
typeof&#40; data&#40;img&#41; &#41;  # returns array with element type UfixedBase&#123;Uint8,8&#125;
typeof&#40; raw&#40;img&#41; &#41;   # returns array with element type Uint8
</code></pre>
<h2 id="imgbasemarkdownlinkanyindexing">imgBase.Markdown.Link(Any[],"indexing")</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">img&#91;i, j, k,...&#93;
img&#91;&quot;x&quot;, 100:200, &quot;y&quot;, 400:600&#93;</code></pre>
<p>return image data as an array. The latter syntax allows you to address dimensions by name, irrespective of the storage order. The returned values have the same storage order as the parent.</p>
<h2 id="getindexim">getindexim</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">getindexim&#40;img, i, j, k,...&#41;
getindexim&#40;img, &quot;x&quot;, 100:200, &quot;y&quot;, 400:600&#41;</code></pre>
<p>return the image data as an <code>Image</code>, copying &#40;and where necessary modifying&#41; the properties of <code>img</code>.</p>
<h2 id="sub-and-slice">sub and slice</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">sub&#40;img, i, j, k, ...&#41;
sub&#40;img, &quot;x&quot;, 100:200, &quot;y&quot;, 400:600&#41;
slice&#40;img, i, j, k, ...&#41;
slice&#40;img, &quot;x&quot;, 15, &quot;y&quot;, 400:600&#41;</code></pre>
<p>returns a <code>SubArray</code> of image data, with the ordinary meanings of <code>sub</code> and <code>slice</code>.</p>
<h2 id="subim-and-sliceim">subim and sliceim</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">subim&#40;img, i, j, k, ...&#41;
subim&#40;img, &quot;x&quot;, 100:200, &quot;y&quot;, 400:600&#41;
sliceim&#40;img, i, j, k, ...&#41;
subim&#40;img, &quot;x&quot;, 15, &quot;y&quot;, 400:600&#41;</code></pre>
<p>returns an <code>Image</code> with <code>SubArray</code> data.</p>
<h1 id="properties-dictionary-like-interface">Properties dictionary-like interface</h1>
<p>Unless specified, these functions work on both plain arrays &#40;when properties can be inferred&#41;, and on <code>Image</code> types.</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">val &#61; img&#91;&quot;propertyname&quot;&#93;
img&#91;&quot;propertyname&quot;&#93; &#61; val</code></pre>
<p>get and set, respectively, the value of a property. These work only for <code>Image</code> types.</p>
<h2 id="haskey">haskey</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">haskey&#40;img, &quot;propertyname&quot;&#41;</code></pre>
<p>Tests whether the named property exists. Returns false for <code>Array</code>s.</p>
<h2 id="get">get</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">get&#40;img, &quot;propertyname&quot;, defaultvalue&#41;</code></pre>
<p>Gets the named property, or returns the default if not present. For <code>Array</code>, the default is always returned.</p>
<h1 id="properties-accessor-function-interface">Properties accessor-function interface</h1>
<p>Unless specified, these functions work on both plain arrays &#40;when properties can be inferred&#41;, and on <code>Image</code> types.</p>
<h2 id="assertd">assert2d</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">assert2d&#40;img&#41;</code></pre>
<p>Triggers an error if the image has more than two spatial dimensions or has a time dimension.</p>
<h2 id="assert_scalar_color">assert_scalar_color</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">assert_scalar_color&#40;img&#41;</code></pre>
<p>Triggers an error if the image uses an array dimension to encode color.</p>
<h2 id="assert_timedim_last">assert_timedim_last</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">assert_timedim_last&#40;img&#41;</code></pre>
<p>Triggers an error if the image has a time dimension that is not the last dimension.</p>
<h2 id="assert_xfirst">assert_xfirst</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">assert_xfirst&#40;img&#41;
assert_yfirst&#40;img&#41;</code></pre>
<p>Triggers an error if the first spatial dimension is not as specified.</p>
<h2 id="colordim">colordim</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">colordim&#40;img&#41;</code></pre>
<p>Returns the dimension used to encode color, or 0 if no dimension of the array is used for color. For example, an <code>Array</code> of size <code>&#40;m, n, 3&#41;</code> would result in 3, whereas an <code>Array</code> of <code>RGB</code> colorvalues would yield 0.</p>
<h2 id="colorspace">colorspace</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">colorspace&#40;img&#41;</code></pre>
<p>Returns a string specifying the colorspace representation of the image.</p>
<h2 id="coords_spatial">coords_spatial</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">coords_spatial&#40;img&#41;</code></pre>
<p>Returns a vector listing the spatial dimensions of the image. For example, an <code>Array</code> of size <code>&#40;m,n,3&#41;</code> would return <code>&#91;1,2&#93;</code>.</p>
<h2 id="height">height</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">height&#40;img&#41;</code></pre>
<p>Returns the vertical size of the image, regardless of storage order. By default horizontal corresponds to dimension <code>&quot;y&quot;</code>, but see <code>spatialpermutation</code> for other options.</p>
<h2 id="isdirect">isdirect</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">isdirect&#40;img&#41;</code></pre>
<p>True if <code>img</code> encodes its values directly, rather than via an indexed colormap.</p>
<h2 id="isxfirst-isyfirst">isxfirst, isyfirst</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">isxfirst&#40;img&#41;
isyfirst&#40;img&#41;</code></pre>
<p>Tests whether the first spatial dimension is <code>&quot;x&quot;</code> or <code>&quot;y&quot;</code>, respectively.</p>
<h2 id="limits">limits</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">limits&#40;img&#41;</code></pre>
<p>Returns the value of the <code>&quot;limits&quot;</code> property, or infers the limits from the data type &#40;e.g., <code>Uint8</code>&#41; when the property does not exist. Setting a default value for FloatingPoint types presents a bit of a challenge; for <code>Image</code> FloatingPoint types, the default is <code>&#40;-Inf, Inf&#41;</code> &#40;consistent with using <code>typemin/typemax</code> for integer types&#41;, but for plain <code>Array</code>s the convention is <code>&#40;0,1&#41;</code>. See also <code>climdefault</code> which always returns a finite value, defaulting to <code>&#40;0,1&#41;</code> for a FloatingPoint image type for which <code>&quot;limits&quot;</code> has not been explicitly set.</p>
<p>For example, if you&#39;re using a 14-bit camera and encoding the values with <code>Uint16</code>, you can set the limits property to <code>&#40;0x0000, 0x3fff&#41;</code> to indicate that not all 16 bits are meaningful.</p>
<p>Note that there is no guarantee that the image values fall within the stated limits; this is intended as a &quot;hint&quot; and is used particularly for setting default contrast when images are displayed.</p>
<p>Arithmetic on images updates the setting of the <code>&quot;limits&quot;</code> property. For example, <code>imgdiff &#61; img1-img2</code>, where both are <code>Image</code>s with <code>&quot;limits&quot;</code> set to <code>&#40;0.0,1.0&#41;</code>, will result in <code>limits&#40;imgdiff&#41; &#61; &#40;-1.0,1.0&#41;</code>.</p>
<h2 id="pixelsplacing">pixelsplacing</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">pixelspacing&#40;img&#41;</code></pre>
<p>Returns a vector containing the spacing between adjacent pixels along each dimension. If this property is not set, it will be computed from <code>&quot;spacedirections&quot;</code> if present; otherwise it defaults to <code>ones&#40;sdims&#40;img&#41;&#41;</code>. If desired, you can set this property in terms of physical <a href="https://github.com/loladiro/SIUnits.jl">units</a>.</p>
<h2 id="spaeddirections">spaeddirections</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">spacedirections&#40;img&#41;</code></pre>
<p>Returns a vector-of-vectors, each indicating the displacement between adjacent pixels along each spatial axis of the image array, relative to some external coordinate system &#40;&quot;physical coordinates&quot;&#41;.  For example, you could indicate that a photograph was taken with the camera tilted 30-degree relative to vertical using</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">img&#91;&quot;spacedirections&quot;&#93; &#61; &#91;&#91;0.866025,-0.5&#93;,&#91;0.5,0.866025&#93;&#93;</code></pre>
<p>If not specified, it will be computed from <code>pixelspacing&#40;img&#41;</code>, placing the spacing along the &quot;diagonal&quot;.  If desired, you can set this property in terms of physical <a href="https://github.com/loladiro/SIUnits.jl">units</a>.</p>
<h2 id="nimages">nimages</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">nimages&#40;img&#41;</code></pre>
<p>The number of time-points in the image array. This is safer than <code>size&#40;img, &quot;t&quot;&#41;</code> because it also works for plain <code>AbstractArray</code> types.</p>
<h2 id="sdims">sdims</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">sdims&#40;img&#41;</code></pre>
<p>Similar to <code>ndims</code>, but it returns just the number of _spatial_ dimensions in the image array &#40;excluding color and time&#41;.</p>
<h2 id="size">size</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">size&#40;img, 2&#41;
size&#40;img, &quot;t&quot;&#41;</code></pre>
<p>Obtains the size of the specified dimension, even for dimensions specified by name. See also <code>nimages</code>, <code>size_spatial</code>, <code>width</code>, <code>height</code>, and <code>widthheight</code>.</p>
<h2 id="size_spatial">size_spatial</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">size_spatial&#40;img&#41;</code></pre>
<p>Returns a tuple listing the sizes of the spatial dimensions of the image. For example, an <code>Array</code> of size <code>&#40;m,n,3&#41;</code> would return <code>&#40;m,n&#41;</code>.</p>
<h2 id="spatialorder">spatialorder</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">spatialorder&#40;img&#41;
spatialorder&#40;ImageType&#41;</code></pre>
<p>Returns the storage order of the _spatial_ coordinates of the image, e.g., <code>&#91;&quot;y&quot;, &quot;x&quot;&#93;</code>. The second version works on a type, e.g., <code>Matrix</code>. See <code>storageorder</code>, <code>timedim</code>, and <code>colordim</code> for related properties.</p>
<h2 id="spatialpermutation">spatialpermutation</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">spatialpermutation&#40;to, img&#41;</code></pre>
<p>Calculates the _spatial_ permutation needed to convert the spatial dimension to a given format. This is probably easiest to understand by examples: for an <code>Array</code> <code>A</code> of size <code>&#40;m,n,3&#41;</code>, <code>spatialorder&#40;A&#41;</code> would yield <code>&#91;&quot;y&quot;, &quot;x&quot;&#93;</code>, so <code>spatialpermutation&#40;&#91;&quot;y&quot;, &quot;x&quot;&#93;, A&#41; &#61; &#91;1,2&#93;</code> and <code>spatialpermutation&#40;&#91;&quot;x&quot;, &quot;y&quot;&#93;, A&#41; &#61; &#91;2,1&#93;</code>.  For an image type, here&#39;s a demonstration:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">julia&gt; Aimg &#61; convert&#40;Image, A&#41;
RGB Image with:
  data: 4x5x3 Array&#123;Float64,3&#125;
  properties:
    limits: &#40;0.0,1.0&#41;
    colordim: 3
    spatialorder:  y x
    colorspace: RGB

julia&gt; Ap &#61; permutedims&#40;Aimg, &#91;3, 1, 2&#93;&#41;
RGB Image with:
  data: 3x4x5 Array&#123;Float64,3&#125;
  properties:
    limits: &#40;0.0,1.0&#41;
    colordim: 1
    spatialorder:  y x
    colorspace: RGB

julia&gt; spatialpermutation&#40;&#91;&quot;x&quot;,&quot;y&quot;&#93;, Ap&#41;
2-element Array&#123;Int64,1&#125;:
 2
 1</code></pre>
<h2 id="spatialproperties">spatialproperties</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">spatialproperties&#40;img&#41;
</code></pre>
<p>Returns all properties whose values are of the form of an array or tuple, with one entry per spatial dimension. If you have a custom type with additional spatial properties, you can set <code>img&#91;&quot;spatialproperties&quot;&#93; &#61; &#91;&quot;property1&quot;, &quot;property2&quot;, ...&#93;</code>. An advantage is that functions that change spatial dimensions, like <code>permutedims</code> and <code>slice</code>, will also adjust the properties. The default is <code>&#91;&quot;spatialorder&quot;, &quot;pixelspacing&quot;&#93;</code>; however, if you override the setting then these are not included automatically &#40;you&#39;ll want to do so manually, if applicable&#41;.</p>
<h2 id="storageorder">storageorder</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">storageorder&#40;img&#41;</code></pre>
<p>Returns the complete storage order of the image array, including <code>&quot;t&quot;</code> for time and <code>&quot;color&quot;</code> for color.</p>
<h2 id="timedim">timedim</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">timedim&#40;img&#41;</code></pre>
<p>Returns the dimension used to represent time, or 0 if this is a single image.</p>
<h2 id="width">width</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">width&#40;img&#41;</code></pre>
<p>Returns the horizontal size of the image, regardless of storage order. By default horizontal corresponds to dimension <code>&quot;x&quot;</code>, but see <code>spatialpermutation</code> for other options.</p>
<h2 id="widthheight">widthheight</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">widthheight&#40;img&#41;</code></pre>
<p>Returns the <code>&#40;w,h&#41;</code> tuple. See <code>width</code> and <code>height</code>.</p>
<h1 id="element-transformation-and-intensity-scaling">Element transformation and intensity scaling</h1>
<p>Many images require some type of transformation before you can use or view them. For example, visualization libraries work in terms of 8-bit data, so if you&#39;re using a 16-bit scientific camera, your image values will need to be scaled before display.</p>
<p>One can directly rescale the pixel intensities in the image array.  In general, element-wise transformations are handled by <code>map</code> or <code>map&#33;</code>, where the latter is used when you want to provide a pre-allocated output.  You can use an anonymous function of your own design, or, if speed is paramount, the &quot;anonymous functions&quot; of the <a href="https://github.com/timholy/FastAnonymous.jl">FastAnonymous</a> package.</p>
<p>Images also supports &quot;lazy transformations.&quot; When loading a very large image, &#40;e.g., loaded by memory-mapping&#41; you may use or view just a small portion of it. In such cases, it would be quite wasteful to force transformation of the entire image, and indeed on might exhaust available memory or need to write a new file on disk.  <code>Images</code> supports lazy-evaluation scaling through the <code>MapInfo</code> abstract type.  The basic syntax is</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">valout &#61; map&#40;mapi::MapInfo, valin&#41;</code></pre>
<p>Here <code>val</code> can refer to a single pixel&#39;s data, or to the entire image array. The <code>mapi</code> input is a type that determines how the input value is scale and converted to a new type.</p>
<h2 id="mapinfo">MapInfo</h2>
<p>Here is how to directly construct the major concrete <code>MapInfo</code> types:</p>
<ul>
<li><code>MapNone&#40;T&#41;</code>, indicating that the only form of scaling is conversion to type   T.  This is not very safe, as values &quot;wrap around&quot;: for example, converting   <code>258</code> to a <code>Uint8</code> results in <code>0x02</code>, which would look dimmer than <code>255 &#61;   0xff</code>.</li>
</ul>
<ul>
<li><code>ClampMin&#40;T, minvalue&#41;</code>, <code>ClampMax&#40;T, maxvalue&#41;</code>, and <code>ClampMinMax&#40;T,   minvalue, maxvalue&#41;</code> create <code>MapInfo</code> objects that clamp pixel values at the   specified min, max, and min/max values, respectively, before   converting. Clamping is equivalent to <code>clampedval &#61; min&#40;max&#40;val, minvalue&#41;,   maxvalue&#41;</code>.  This is much safer than <code>MapNone</code>.</li>
</ul>
<ul>
<li><code>BitShift&#40;T, N&#41;</code> or <code>BitShift&#123;T,N&#125;&#40;&#41;</code>, for scaling by bit-shift operators.   <code>N</code> specifies the number of bits to right-shift by.  For example you could   convert a 14-bit image to 8-bits using <code>BitShift&#40;Uint8, 6&#41;</code>.  In general this   will be faster than using multiplication.</li>
</ul>
<ul>
<li><code>ScaleMinMax&#40;T, min, max, &#91;scalefactor&#93;&#41;</code> clamps the image at the specified   min/max values, subtracts the min value, scales the result by multiplying by   <code>scalefactor</code>, and finally converts the type.  If <code>scalefactor</code> is not   specified, it defaults to scaling the range <code>&#91;min,max&#93;</code> to <code>&#91;0,1&#93;</code>.</li>
</ul>
<ul>
<li><code>ScaleAutoMinMax&#40;T&#41;</code> will cause images to be dynamically scaled to their   specific min/max values, using the same algorithm for <code>ScaleMinMax</code>. When   displaying a movie, the min/max will be recalculated for each frame, so this   can result in inconsistent contrast scaling.</li>
</ul>
<ul>
<li><code>ScaleSigned&#40;T, scalefactor&#41;</code> multiplies the image by the scalefactor, then   clamps to the range <code>&#91;-1,1&#93;</code>. If <code>T</code> is a floating-point type, it stays in   this representation.  If <code>T</code> is <code>RGB24</code> or <code>RGB&#123;Ufixed8&#125;</code>, then it is encoded   as a magenta &#40;positive&#41;/green &#40;negative&#41; image.</li>
</ul>
<p>There are also convenience functions:</p>
<h2 id="imstretch">imstretch</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imstretch&#40;img, m, slope&#41;</code></pre>
<p>which, for an image with intensities between 0 and 1, enhances or reduces &#40;for slope &gt; 1 or &lt; 1, respectively&#41; the contrast near saturation &#40;0 and 1&#41;. This is essentially a symmetric gamma-correction. For a pixel of brightness <code>p</code>, the new intensity is <code>1/&#40;1&#43;m/&#40;p&#43;eps&#41;^slope&#41;</code>.</p>
<h2 id="sc">sc</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">sc&#40;img&#41;
sc&#40;img, min, max&#41;</code></pre>
<p>Applies default or specified ScaleMinMax scaling to the image.</p>
<h2 id="mapinfo">mapinfo</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">mapinfo&#40;client, img&#41;</code></pre>
<p>returns the default scaling for a specified &quot;client.&quot; For example, clients <code>RGB24</code> and <code>ARGB32</code> are used for display, and <code>Images.ImageMagick</code> is used when saving to disk. You could define additional implementations for custom clients.</p>
<h1 id="color-conversion">Color conversion</h1>
<h2 id="convert">convert</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">convert&#40;Image&#123;Color&#125;, img&#41;</code></pre>
<p>as described above. Use <code>convert&#40;Image&#123;Gray&#125;, img&#41;</code> to calculate a grayscale representation of a color image using the <a href="http://en.wikipedia.org/wiki/Luma_&#37;28video&#37;29#Rec._601_luma_versus_Rec._709_luma_coefficients">Rec 601 luma</a>.</p>
<h2 id="map">map</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">map&#40;mapi, img&#41;
map&#33;&#40;mapi, dest, img&#41;</code></pre>
<p>can be used to specify both the form of the result and the algorithm used.</p>
<h1 id="image-io">Image I/O</h1>
<p>See also the more <a href="extendingIO.html">thorough description</a>.</p>
<h2 id="add_image_file_format">add_image_file_format</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">add_image_file_format&#40;extension, &#91;magicbytes,&#93; FileType, srcfilename&#41;</code></pre>
<p>&quot;Register&quot; a source file that can handle reading/writing image files of the given format. <code>FileType</code> must be a subtype of <code>ImageFileType</code>. For those &#40;unfortunate&#41; formats without magic bytes, you can still register them, but reading will be based solely on extension name and/or can be forced by specifying the file type in <code>imread</code>.</p>
<h2 id="imread">imread</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imread&#40;filename;&#91;extraprop&#61;&quot;&quot;,extrapropertynames&#61;false&#93;&#41;
imread&#40;filename, FileType;&#91;extraprop&#61;&quot;&quot;,extrapropertynames&#61;false&#93;&#41;
imread&#40;stream, FileType&#41;</code></pre>
<p>Reads an image, inferring the format from &#40;1&#41; the magic bytes where possible &#40;even if this doesn&#39;t agree with the extension name&#41;, and &#40;2&#41; otherwise by the extension name. The format can also be directly controlled by <code>FileType</code>.</p>
<p>Note that imread will return images in native storage format, e.g., a 2D RGB image will &#40;for most file formats&#41; be returned as a 2D <code>RGB</code> array. Because file formats are horizontal major, you access the value of pixel <code>&#40;x,y&#41;</code> by <code>img&#91;x,y&#93;</code> or <code>img&#91;&quot;x&quot;,x,&quot;y&quot;,y&#93;</code>.</p>
<p>When reading with ImageMagick, arbitrary properties of the image can be transfered to the properties dictionary. If <code>extrapropertynames</code> is <code>true</code>, <code>imread</code> just returns a vector of the property names stored in the image. The <code>extraprop</code> argument takes a string or a vector of strings and adds the named properties to the dictionary.</p>
<h2 id="imwrite">imwrite</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imwrite&#40;img, filename, &#91;FileType,&#93; args...&#41;</code></pre>
<p>Write an image, specifying the type by the extension name or &#40;optionally&#41; directly. Some writers take additional arguments, for example</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imwrite&#40;img, &quot;myimage.jpg&quot;, quality&#61;80&#41;</code></pre>
<p>to control the quality setting in JPEG compression. Another useful keyword argument is <code>mapi</code>, which allows you apply a MapInfo transformation on the elements before writing. For example, if you have floating-point images whose values are sometimes out-of-bounds &#40;smaller than 0 or bigger than 1&#41;, you can avoid an error upon writing with</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imwrite&#40;img, &quot;myimage.png&quot;, mapi&#61;mapinfo&#40;Clamp, img&#41;&#41;</code></pre>
<p>and values will be clamped, as needed, before writing.</p>
<h2 id="loadformat">loadformat</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">loadformat&#40;FileType&#41;</code></pre>
<p>Image file format code &#40;in the <code>src/io</code> directory&#41; is not loaded until needed, usually triggered by reading or writing a file of the given format. You can use this command to force the format to load, for example to gain access to specific functions in the corresponding module. See the end of <code>io.jl</code> for a list of <code>FileType</code>s.</p>
<h2 id="writemime">writemime</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">writemime&#40;io, MIME&#40;&quot;image/png&quot;&#41;, img; mapi&#61;Images.mapinfo_writemime&#40;img&#41;, minpixels&#61;10^4, maxpixels&#61;10^6&#41;</code></pre>
<p>Write to stream <code>io</code> as a PNG. This is used for display front-ends such as IJulia.  The keyword arguments allow you to specify the <code>mapinfo</code> transformation to be used, the minimum number of pixels used to display the image, and the maximum number of pixels used, respectively. Shrinking is performed by <code>restrict</code>; enlarging is done by duplication of adjacent pixels.</p>
<h1 id="image-algorithms">Image algorithms</h1>
<p>You can perform arithmetic with <code>Image</code>s and <code>Color</code>s. Algorithms also include the following functions:</p>
<h1 id="linear-filtering-and-padding">Linear filtering and padding</h1>
<h2 id="imfilter">imfilter</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imfilter&#40;img, kernel, &#91;border, value&#93;&#41;</code></pre>
<p>filters the image with the given &#40;array&#41; kernel, using boundary conditions specified by <code>border</code> and <code>value</code>. See <code>padarray</code> below for an explanation of the boundary conditions. Default is to use <code>&quot;replicate&quot;</code> boundary conditions. This uses finite-impulse-response &#40;FIR&#41; filtering, and is fast only for relatively small <code>kernel</code>s.</p>
<h2 id="imfilter">imfilter!</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imfilter&#33;&#40;dest, img, kernel&#41;</code></pre>
<p>filters the image with the given &#40;array&#41; kernel, storing the output in the pre-allocated output <code>dest</code>. The size of <code>dest</code> must not be greater than the size of the result of <code>imfilter</code> with <code>border &#61; &quot;inner&quot;</code>, and it behaves identically.  This uses finite-impulse-response &#40;FIR&#41; filtering, and is fast only for relatively small <code>kernel</code>s.</p>
<h2 id="imfilter_fft">imfilter_fft</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imfilter_fft&#40;img, kernel, &#91;border, value&#93;&#41;</code></pre>
<p>filters the image with the given &#40;array&#41; kernel, using an FFT algorithm.  This is slower than <code>imfilter</code> for small kernels, but much faster for large kernels. For Gaussian blur, an even better choice is <code>imfilter_gaussian</code>.</p>
<h2 id="imfilter_gaussian">imfilter_gaussian</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imfilter_gaussian&#40;img, sigma&#41;</code></pre>
<p>filters the image with a Gaussian of the specified width. <code>sigma</code> should have one value per array dimension &#40;any number of dimensions are supported&#41;, 0 indicating that no filtering is to occur along that dimension. Uses the Young, van Vliet, and van Ginkel IIR-based algorithm to provide fast gaussian filtering even with large <code>sigma</code>. Edges are handled by &quot;NA&quot; conditions, meaning the result is normalized by the number and weighting of available pixels, and missing data &#40;NaNs&#41; are handled likewise.</p>
<h2 id="imfilter_log">imfilter_LoG</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imfilter_LoG&#40;img, sigma, &#91;border&#93;&#41;</code></pre>
<p>filters a 2D image with a Laplacian of Gaussian of the specified width. <code>sigma</code> may be a vector with one value per array dimension, or may be a single scalar value for uniform filtering in both dimensions.  Uses the Huertas and Medioni separable algorithm.</p>
<h2 id="imgradients">imgradients</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imgradients&#40;img, &#91;method&#93;, &#91;border&#93;&#41;</code></pre>
<p>Edge-detection filtering. <code>method</code> is one of <code>&quot;sobel&quot;</code>, <code>&quot;prewitt&quot;</code>, <code>&quot;ando3&quot;</code>, <code>&quot;ando4&quot;</code>, <code>&quot;ando4_sep&quot;</code>, <code>&quot;ando5&quot;</code>, or <code>&quot;ando5_sep&quot;</code>, defaulting to <code>&quot;ando3&quot;</code> &#40;see the functions of the same name for more information&#41;.  <code>border</code> is any of the boundary conditions specified in <code>padarray</code>.</p>
<p>Returns a tuple containing <code>x</code> &#40;horizontal&#41; and <code>y</code> &#40;vertical&#41; gradient images of the same size as <code>img</code>, calculated using the requested method and border.</p>
<h2 id="magnitude">magnitude</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">magnitude&#40;grad_x, grad_y&#41;</code></pre>
<p>Calculates the magnitude of the gradient images given by <code>grad_x</code> and <code>grad_y</code>. Equivalent to <code>sqrt&#40;grad_x.^2 &#43; grad_y.^2&#41;</code>.</p>
<p>Returns a magnitude image the same size as <code>grad_x</code> and <code>grad_y</code>.</p>
<h2 id="phase">phase</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">phase&#40;grad_x, grad_y&#41;</code></pre>
<p>Calculates the rotation angle of the gradient images given by <code>grad_x</code> and <code>grad_y</code>. Equivalent to <code>atan2&#40;-grad_y, grad_x&#41;</code>.  When both <code>grad_x&#91;i&#93;</code> and <code>grad_y&#91;i&#93;</code> are zero, the corresponding angle is set to zero.</p>
<p>Returns a phase image the same size as <code>grad_x</code> and <code>grad_y</code>, with values in &#91;-pi,pi&#93;.</p>
<h2 id="orientation">orientation</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">orientation&#40;grad_x, grad_y&#41;</code></pre>
<p>Calculates the orientation angle of the strongest edge from gradient images given by <code>grad_x</code> and <code>grad_y</code>.  Equivalent to <code>atan2&#40;grad_x, grad_y&#41;</code>.  When both <code>grad_x&#91;i&#93;</code> and <code>grad_y&#91;i&#93;</code> are zero, the corresponding angle is set to zero.</p>
<p>Returns a phase image the same size as <code>grad_x</code> and <code>grad_y</code>, with values in &#91;-pi,pi&#93;.</p>
<h2 id="magnitude_phase">magnitude_phase</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">magnitude_phase&#40;grad_x, grad_y&#41;</code></pre>
<p>Convenience function for calculating the magnitude and phase of the gradient images given in <code>grad_x</code> and <code>grad_y</code>.  Returns a tuple containing the magnitude and phase images.  See <code>magnitude</code> and <code>phase</code> for details.</p>
<h2 id="imedge">imedge</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imedge&#40;img, &#91;method&#93;, &#91;border&#93;&#41;</code></pre>
<p>Edge-detection filtering. <code>method</code> is one of <code>&quot;sobel&quot;</code>, <code>&quot;prewitt&quot;</code>, <code>&quot;ando3&quot;</code>, <code>&quot;ando4&quot;</code>, <code>&quot;ando4_sep&quot;</code>, <code>&quot;ando5&quot;</code>, or <code>&quot;ando5_sep&quot;</code>, defaulting to <code>&quot;ando3&quot;</code> &#40;see the functions of the same name for more information&#41;.  <code>border</code> is any of the boundary conditions specified in <code>padarray</code>.</p>
<p>Returns a tuple <code>&#40;grad_x, grad_y, mag, orient&#41;</code>, which are the horizontal gradient, vertical gradient, and the magnitude and orientation of the strongest edge, respectively.</p>
<h2 id="thin_edges">thin_edges</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">thin_edges&#40;img, gradientangle, &#91;border&#93;&#41;
thin_edges_subpix&#40;img, gradientangle, &#91;border&#93;&#41;
thin_edges_nonmaxsup&#40;img, gradientangle, &#91;border&#93;; &#91;radius::Float64&#61;1.35&#93;, &#91;theta&#61;pi/180&#93;&#41;
thin_edges_nonmaxsup_subpix&#40;img, gradientangle, &#91;border&#93;; &#91;radius::Float64&#61;1.35&#93;, &#91;theta&#61;pi/180&#93;&#41;</code></pre>
<p>Edge thinning for 2D edge images.  Currently the only algorithm available is non-maximal suppression, which takes an edge image and its gradient angle, and checks each edge point for local maximality in the direction of the gradient. The returned image is non-zero only at maximal edge locations.</p>
<p><code>border</code> is any of the boundary conditions specified in <code>padarray</code>.</p>
<p>In addition to the maximal edge image, the <code>_subpix</code> versions of these functions also return an estimate of the subpixel location of each local maxima, as a 2D array or image of <code>Graphics.Point</code> objects.  Additionally, each local maxima is adjusted to the estimated value at the subpixel location.</p>
<p>Currently, the <code>_nonmaxsup</code> functions are identical to the first two function calls, except that they also accept additional keyword arguments.  <code>radius</code> indicates the step size to use when searching in the direction of the gradient; values between 1.2 and 1.5 are suggested &#40;default 1.35&#41;.  <code>theta</code> indicates the step size to use when discretizing angles in the <code>gradientangle</code> image, in radians &#40;default: 1 degree in radians &#61; pi/180&#41;.</p>
<p>Example:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">g &#61; rgb2gray&#40;rgb_image&#41;
gx, gy &#61; imgradients&#40;g&#41;
mag, grad_angle &#61; magnitude_phase&#40;gx,gy&#41;
mag&#91;mag .&lt; 0.5&#93; &#61; 0.0  # Threshold magnitude image
thinned, subpix &#61;  thin_edges_subpix&#40;mag, gradient&#41;</code></pre>
<h2 id="thin_edges">thin_edges!</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">thin_edges_nonmaxsup&#33;&#40;out, img, gradientangle, &#91;border&#93;; &#91;radius::Float64&#61;1.35&#93;, &#91;theta&#61;pi/180&#93;&#41;
thin_edges_nonmaxsup_subpix&#33;&#40;out, location, img, gradientangle, &#91;border&#93;; &#91;radius::Float64&#61;1.35&#93;, &#91;theta&#61;pi/180&#93;&#41;</code></pre>
<p>For advanced usage, these versions will put results into preallocated arrays or images.  <code>out</code> must be the same size and type as <code>img</code>.  <code>location</code> must be an array of type <code>Graphics.Point</code> and must be the same size as <code>img</code>.</p>
<h2 id="forwarddiffx-backdiffx">forwarddiffx, backdiffx</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">forwarddiffx&#40;img&#41;
backdiffx&#40;img&#41;
forwarddiffy&#40;img&#41;
backdiffy&#40;img&#41;</code></pre>
<p>Forward- and backward finite differencing along the x- and y- axes. The size of the image is preserved, so the first &#40;for <code>backdiff</code>&#41; or last &#40;for <code>forwarddiff</code>&#41; row/column will be zero. These currently operate only on matrices &#40;2d with scalar color&#41;.</p>
<h2 id="padarray">padarray</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">padarray&#40;img, prepad, postpad, border, value&#41;</code></pre>
<p>For an <code>N</code>-dimensional array, apply padding on both edges. <code>prepad</code> and <code>postpad</code> are vectors of length <code>N</code> specifying the number of pixels used to pad each dimension. <code>border</code> is a string, one of <code>&quot;value&quot;</code> &#40;to pad with a specific pixel value&#41;, <code>&quot;replicate&quot;</code> &#40;to repeat the edge value&#41;, <code>&quot;circular&quot;</code> &#40;periodic boundary conditions&#41;, <code>&quot;reflect&quot;</code> &#40;reflecting boundary conditions, where the reflection is centered on edge&#41;, and <code>&quot;symmetric&quot;</code> &#40;reflecting boundary conditions, where the reflection is centered a half-pixel spacing beyond the edge, so the edge value gets repeated&#41;. Arrays are automatically padded before filtering. Use <code>&quot;inner&quot;</code> to avoid padding altogether; the output array will be smaller than the input.</p>
<h1 id="filtering-kernels">Filtering kernels</h1>
<h2 id="gaussiand">gaussian2d</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">gaussian2d&#40;sigma, filtersize&#41;</code></pre>
<p>returns a kernel for FIR-based Gaussian filtering. See also <code>imfilter_gaussian</code>.</p>
<h2 id="imaverage">imaverage</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imaverage&#40;filtersize&#41;</code></pre>
<p>constructs a boxcar-filter of the specified size.</p>
<h2 id="imdog">imdog</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imdog&#40;sigma&#41;</code></pre>
<p>creates a difference-of-gaussians kernel &#40;<code>sigma</code>s differing by a factor of <code>sqrt&#40;2&#41;</code>&#41;</p>
<h2 id="imlaplacian">imlaplacian</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imlaplacian&#40;filtersize&#41;</code></pre>
<p>returns a kernel for laplacian filtering.</p>
<h2 id="imlog">imlog</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imlog&#40;sigma&#41;</code></pre>
<p>returns a laplacian-of-gaussian kernel.</p>
<h2 id="sobel-prewitt-ando">sobel, prewitt, ando</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">sobel&#40;&#41;
prewitt&#40;&#41;
ando3&#40;&#41;
ando4&#40;&#41;
ando4_sep&#40;&#41;
ando5&#40;&#41;
ando5_sep&#40;&#41;</code></pre>
<p>Return x- and y- derivative filters of the specified type:</p>
<table><tr><th>Name</th><th>Description</th></tr><tr><td><code>&quot;sobel&quot;</code></td><td>Sobel filter</td></tr><tr><td><code>&quot;prewitt&quot;</code></td><td>Prewitt filter</td></tr><tr><td><code>&quot;ando3&quot;</code></td><td>Optimal 3x3 filter from Ando 2000</td></tr><tr><td><code>&quot;ando4&quot;</code></td><td>Optimal 4x4 filter from Ando 2000</td></tr><tr><td><code>&quot;ando4_sep&quot;</code></td><td>Separable approximation of <code>&quot;ando4&quot;</code></td></tr><tr><td><code>&quot;ando5&quot;</code></td><td>Optimal 5x5 filter from Ando 2000</td></tr><tr><td><code>&quot;ando5_sep&quot;</code></td><td>Separable approximation of <code>&quot;ando5&quot;</code></td></tr></table>
<p>The ando filters were derived in Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000.  As written in the paper, the 4x4 and 5x5 papers are not separable, so the <code>&quot;ando4_sep&quot;</code> and <code>&quot;ando5_sep&quot;</code> filters are provided as separable &#40;and therefore faster&#41; approximations of <code>&quot;ando4&quot;</code> and <code>&quot;ando5&quot;</code>, respectively.</p>
<h1 id="nonlinear-filtering-and-transformation">Nonlinear filtering and transformation</h1>
<h2 id="imrof">imROF</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">imROF&#40;img, lambda, iterations&#41;</code></pre>
<p>Perform Rudin-Osher-Fatemi &#40;ROF&#41; filtering, more commonly known as Total Variation &#40;TV&#41; denoising or TV regularization. <code>lambda</code> is the regularization coefficient for the derivative, and <code>iterations</code> is the number of relaxation iterations taken. 2d only.</p>
<h1 id="resizing">Resizing</h1>
<h2 id="restrict">restrict</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">restrict&#40;img&#91;, region&#93;&#41;</code></pre>
<p>performs two-fold reduction in size along the dimensions listed in <code>region</code>, or all spatial coordinates if <code>region</code> is not specified.  It anti-aliases the image as it goes, so is better than a naive summation over 2x2 blocks.</p>
<h1 id="image-statistics">Image statistics</h1>
<h2 id="minfinite-maxfinite-maxabsfinite">minfinite, maxfinite, maxabsfinite</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">minfinite&#40;img&#41;
maxfinite&#40;img&#41;
maxabsfinite&#40;img&#41;</code></pre>
<p>Return the minimum and maximum value in the image, respectively, ignoring any values that are not finite &#40;Inf or NaN&#41;.</p>
<h2 id="meanfinite">meanfinite</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">meanfinite&#40;img, region&#41;</code></pre>
<p>Calculate the mean value along the dimensions listed in <code>region</code>, ignoring any non-finite values.</p>
<h2 id="ssd-ssdn">ssd, ssdn</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">ssd&#40;img1, img2&#41;
ssdn&#40;img1, img2&#41;</code></pre>
<p>Sum-of-squared-differences &#40;pixelwise&#41;. <code>ssdn</code> is the mean-of-squared-differences &#40;i.e., normalized by <code>n</code>, the number of pixels&#41;.</p>
<h2 id="sad-sadn">sad, sadn</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">sad&#40;img1, img2&#41;
sadn&#40;img1, img2&#41;</code></pre>
<p>sum and mean of <code>abs&#40;img1-img2&#41;</code>.</p>
<h1 id="morphological-operations">Morphological operations</h1>
<h2 id="dilate-erode">dilate, erode</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">dilate&#40;img, &#91;region&#93;&#41;
erode&#40;img, &#91;region&#93;&#41;</code></pre>
<p>perform a max-filter and min-filter, respectively, over nearest-neighbors. The default is 8-connectivity in 2d, 27-connectivity in 3d, etc. You can specify the list of dimensions that you want to include in the connectivity, e.g., region &#61; &#91;1,2&#93; would exclude the third dimension from filtering.</p>
<h2 id="opening-closing">opening, closing</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">opening&#40;img, &#91;region&#93;&#41;
closing&#40;img, &#91;region&#93;&#41;</code></pre>
<p>perform the <code>opening</code> and <code>closing</code> morphology operations. <code>opening</code> does first <code>erode</code> the image and then <code>dilate</code> the image. <code>opening</code> applies both operations in the oposite way. The region parameter is passed to <code>erode</code> and <code>dilate</code> and describes the kernel size over which these operations are performed.</p>
<h2 id="label_components">label_components</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">label_components&#40;tf, &#91;connectivity&#93;&#41;
label_components&#40;tf, &#91;region&#93;&#41;</code></pre>
<p>Find the connected components in a binary array <code>tf</code>. There are two forms that <code>connectivity</code> can take: it can be a boolean array of the same dimensionality as <code>tf</code>, of size 1 or 3 along each dimension. Each entry in the array determines whether a given neighbor is used for connectivity analyses. For example,</p>
<h2 id="connectivity">connectivity</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">connectivity &#61; trues&#40;3,3&#41;</code></pre>
<p>would use 8-connectivity and test all pixels that touch the current one, even the corners.  The other form is specific for connectivity to just the nearest neighbors &#40;e.g., 4-connectivity in 2d and 6-connectivity in 3d&#41;. You can provide a list indicating which dimensions are used to determine connectivity. For example, <code>region &#61; &#91;1,3&#93;</code> would not test neighbors along dimension 2 for connectivity.</p>
<p>The default is <code>region &#61; 1:ndims&#40;A&#41;</code>.</p>
<p>The output is an integer array, where 0 is used for background pixels, and each connected region gets a different integer index.</p>
<h1 id="phantoms">Phantoms</h1>
<h2 id="shepp_logan">shepp_logan</h2>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">shepp_logan&#40;N,&#91;M&#93;; highContrast&#61;true&#41;</code></pre>
<p>output the NxM Shepp-Logan phantom, which is a standard test image usually used for comparing image reconstruction algorithms in the field of computed tomography &#40;CT&#41; and magnetic resonance imaging &#40;MRI&#41;. If the argument M is omitted, the phantom is of size NxN. When setting the keyword argument &#96;&#96;highConstrast&#96; to false, the CT version of the phantom is created. Otherwise, the high contrast MRI version is calculated.</p>

      <hr>
      </div>
      </div>

      <div class="col-sm-offset-8" style="z-index: 2">
        <div id="table-of-contents">
          <div id="table-of-contents-content">
            <input class="search" placeholder="SEARCH" />
            <ul class="toc list nav"><li>
    <a class="toc-item" href="index.html">Introduction</a>
</li>
<li>
    <a class="toc-item" href="aims.html">Aims</a>
</li>
<li>
    <a class="toc-item" href="install.html">Installation</a>
</li>
<li>
    <a class="toc-item" href="core.html">Core Concepts</a>
</li>
<li>
    <a class="toc-item toc-current-doc" href="function_reference.html">Function Reference</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#image-construction">Image construction</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#image-type">Image (type)</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imagecmap">ImageCmap</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#convert">convert</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#grayim">grayim</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#colorim">colorim</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#copyproperties">copyproperties</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#shareproperties">shareproperties</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#similar">similar</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#overlay">Overlay</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#overlayimage">OverlayImage</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#accessing-image-data">Accessing image data</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#data">data</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#raw">raw</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#img">img</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#getindexim">getindexim</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#sub-and-slice">sub and slice</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#subim-and-sliceim">subim and sliceim</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#properties-dictionary-like-interface">Properties dictionary-like interface</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#haskey">haskey</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#get">get</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#properties-accessor-function-interface">Properties accessor-function interface</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#assertd">assert2d</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#assert_scalar_color">assert_scalar_color</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#assert_timedim_last">assert_timedim_last</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#assert_xfirst">assert_xfirst</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#colordim">colordim</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#colorspace">colorspace</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#coords_spatial">coords_spatial</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#height">height</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#isdirect">isdirect</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#isxfirst-isyfirst">isxfirst, isyfirst</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#limits">limits</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#pixelsplacing">pixelsplacing</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#spaeddirections">spaeddirections</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#nimages">nimages</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#sdims">sdims</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#size">size</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#size_spatial">size_spatial</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#spatialorder">spatialorder</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#spatialpermutation">spatialpermutation</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#spatialproperties">spatialproperties</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#storageorder">storageorder</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#timedim">timedim</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#width">width</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#widthheight">widthheight</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#element-transformation-and-intensity-scaling">Element transformation and intensity scaling</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#mapinfo">MapInfo</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imstretch">imstretch</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#sc">sc</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#mapinfo">mapinfo</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#color-conversion">Color conversion</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#convert">convert</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#map">map</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#image-io">Image I/O</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#add_image_file_format">add_image_file_format</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imread">imread</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imwrite">imwrite</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#loadformat">loadformat</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#writemime">writemime</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#image-algorithms">Image algorithms</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#linear-filtering-and-padding">Linear filtering and padding</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imfilter">imfilter</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imfilter">imfilter!</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imfilter_fft">imfilter_fft</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imfilter_gaussian">imfilter_gaussian</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imfilter_log">imfilter_LoG</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imgradients">imgradients</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#magnitude">magnitude</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#phase">phase</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#orientation">orientation</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#magnitude_phase">magnitude_phase</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imedge">imedge</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#thin_edges">thin_edges</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#thin_edges">thin_edges!</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#forwarddiffx-backdiffx">forwarddiffx, backdiffx</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#padarray">padarray</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#filtering-kernels">Filtering kernels</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#gaussiand">gaussian2d</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imaverage">imaverage</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imdog">imdog</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imlaplacian">imlaplacian</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imlog">imlog</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#sobel-prewitt-ando">sobel, prewitt, ando</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#nonlinear-filtering-and-transformation">Nonlinear filtering and transformation</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#imrof">imROF</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#resizing">Resizing</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#restrict">restrict</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#image-statistics">Image statistics</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#minfinite-maxfinite-maxabsfinite">minfinite, maxfinite, maxabsfinite</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#meanfinite">meanfinite</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#ssd-ssdn">ssd, ssdn</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#sad-sadn">sad, sadn</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#morphological-operations">Morphological operations</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#dilate-erode">dilate, erode</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#opening-closing">opening, closing</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#label_components">label_components</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#connectivity">connectivity</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#phantoms">Phantoms</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#shepp_logan">shepp_logan</a>
</li>
<li>
    <a class="toc-item" href="overlays.html">Overlays</a>
</li>
<li>
    <a class="toc-item" href="extendingIO.html">Extending IO</a>
</li>
<li>
    <a class="toc-item" href="status.html">Development Status</a>
</li>
</ul>

            <script>
                var toclist = new List("table-of-contents",
                                       {valueNames: ["toc-item"]})

                $("body").scrollspy({target: "#table-of-contents"});

                $("#table-of-contents li").on("activate.bs.scrollspy",
                    function(event) {
                        $("#table-of-contents ul").find("a").css({"font-weight": "normal"});
                        $(this).children("a").css({"font-weight": "bolder"});
                    });
            </script>
          </div>
        </div>
      </div>
    </div>

  <footer class="col-sm-8">
    <p class="muted">Last modified by Tim Holy on . Generated with
    <a href="https://github.com/dcjones/Judo.jl">Judo</a>.</p>
  </footer>

  </div>
</body>
</html>

