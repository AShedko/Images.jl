<!DOCTYPE html>
<html>
<head>
  <meta name="author" content="Tim Holy">
  <meta charset="utf-8">
  <title>Core Concepts</title>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro:400,700'
        rel='stylesheet' type='text/css'>
  <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/custom.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/hk-pyg.css" rel="stylesheet" type="text/css" media="all">
  <script src="js/jquery-2.0.3.min.js" type="text/javascript"></script>
  <script src="js/bootstrap.min.js" type="text/javascript"></script>
  <script src="js/list.min.js" type="text/javascript"></script>
</head>
<body>
  <div id="topbar" style="z-index: 3">
    <div class="container">
      <div class="row">
        <ul>
          <li><div id="pkgname">Images 0.4.47+</div></li>
          <li><a href="http:&#x2F;&#x2F;github.com&#x2F;timholy&#x2F;Images.jl">Code</a></li>
          <li><a href="http:&#x2F;&#x2F;github.com&#x2F;timholy&#x2F;Images.jl/issues">Issues</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container" style="z-index: auto">
    <div class="row">
      <div class="col-sm-7">
      <div id="body-content">
      <h1>Julia Images Guide</h1>
<h1 id="the-basic-types">The basic types</h1>
<h2 id="plain-arrays">Plain arrays</h2>
<p>Images can be plain arrays, which are interpreted to be in &quot;Matlab format&quot;: the first two dimensions are height &#40;<code>h</code>&#41; and width &#40;<code>w</code>&#41;, a storage order here called &quot;vertical-major&quot;. This ordering is inspired by the column/row index order of matrices and the desire to have a displayed image look like what one sees when a matrix is written out in text.</p>
<p>If you&#39;re working with RGB color, your best approach is to encode color as a <code>Color</code>, as defined in the <code>Color</code> package.  That package provides many utility functions for analyzing and manipulating colors.  Alternatively, you can use a third dimension of size 3, or encode your images as either <code>RGB24</code> or <code>ARGB32</code>, which use an internal <code>Uint32</code> representation of color.</p>
<p>It&#39;s worth noting that these Matlab conventions are sometimes inconvenient.  For example, the <code>x</code> coordinate &#40;horizontal&#41; is second and the <code>y</code> coordinate &#40;vertical&#41; is first; in other words, one uses <code>img&#91;y,x&#93;</code> to address a pixel that is displayed at a particular <code>x,y</code> position. This often catches newcomers &#40;and sometimes even old-timers&#41; by surprise.  Moreover, most image file formats, cameras, and graphics libraries such as Cairo use &quot;horizontal-major&quot; storage of images, and have the color dimension first &#40;fastest&#41;. The native Image type–-which allows arbitrary ordering of the data array–-permits you to use this raw representation directly, but when using plain arrays you need to permute the dimensions of the raw data array.</p>
<p>The convention that a <code>m x n x 3</code> array implies RGB is also problematic for anyone doing 3d imaging, and can result in hard-to-find bugs when the third dimension happens to be of size 3. For 3d imaging, the use of an Image type–-perhaps converting Arrays via <code>grayim</code>–-is highly recommended.</p>
<p>The conventions for plain arrays are &quot;baked in&quot; via a few simple utility functions in the file <code>core.jl</code>; if you really need to use plain arrays but want to work with different conventions, you can &#40;locally&#41; change these defaults with just a few lines. Algorithms which have been written generically should continue to work.</p>
<p>However, a more flexible approach is to use one of the self-documenting image types.</p>
<h2 id="image-types">Image types</h2>
<p>All image types should descend from <code>AbstractImage</code>, an abstract base type used to indicate that an array is to be interpreted as an image. If you&#39;re writing a custom image type, it is more likely that you&#39;ll want to derive from either <code>AbstractImageDirect</code> or <code>AbstractImageIndexed</code>. The former is for direct images &#40;where intensity at a pixel is represented directly&#41;, the latter for indexed images &#40;where intensity is looked up in a colormap table&#41;.</p>
<p>In practice, it is assumed that <code>AbstractImages</code> have at least two fields, called <code>data</code> and <code>properties</code>. &#40;In code, you should not use these directly, instead using the functions <code>data</code> and <code>properties</code> to extract these.&#41;  These are the only two fields in the first concrete image type, called <code>Image</code>:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">type Image&#123;T,N,A&lt;:AbstractArray&#125; &lt;: AbstractImageDirect&#123;T,N&#125;
    data::A
    properties::Dict&#123;ASCIIString,Any&#125;
end</code></pre>
<p><code>data</code> stores the actual image data, and is an <code>AbstractArray</code>. This fact alone is the basis for a great deal of customizability: <code>data</code> might be a plain <code>Array</code> stored in memory, a <code>SubArray</code>, a memory-mapped array &#40;which is still just an <code>Array</code>&#41;, a custom type that stores additional information about &quot;missing data&quot; &#40;like bad pixels or dropped frames&#41;, or a custom type that seamlessly presents views of a large number of separate files.  One concrete example in the Images codebase is the color <code>Overlay</code> <a href="overlays.html">type</a>.  If you have a suitably-defined <code>AbstractArray</code> type, you can probably use <code>Image</code> without needing to create alternative <code>AbstractImageDirect</code> types.</p>
<p><code>properties</code> is a dictionary, with <code>String</code> keys, that allows you to annotate images. More detail about this point can be found below.</p>
<p>The only other concrete image type is for indexed images:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">type ImageCmap&#123;T,N,A&lt;:AbstractArray,C&lt;:AbstractArray&#125; &lt;: AbstractImageIndexed&#123;T,N&#125;
    data::A
    cmap::C
    properties::Dict&#123;ASCIIString,Any&#125;
end</code></pre>
<p>The <code>data</code> array here just encodes the index used to look up the color in the <code>cmap</code> field.</p>
<h1 id="addressing-image-data">Addressing image data</h1>
<p>For any valid image type, <code>data&#40;img&#41;</code> returns the array that corresponds to the image.  This works when <code>img</code> is a plain <code>Array</code> &#40;in which case no operation is performed&#41; as well as for an <code>Image</code> &#40;in which case it returns <code>img.data</code>&#41;. For some image formats, Images.jl may interpret raw data with the <code>FixedPointNumbers</code> package. The function <code>raw&#40;img&#41;</code> can be used to recover the buffer in its raw format &#40;e.g. <code>UInt8</code>&#41;. This is our first example of how to write generic algorithms.</p>
<p>If <code>img</code> is an <code>Image</code>, then <code>img&#91;i,j&#93;</code> looks up the value <code>img.data&#91;i,j&#93;</code>. Assignment, <code>sub</code>, and <code>slice</code> work similarly. In other words, for indexing an <code>Image</code> works just as if you were using plain arrays.</p>
<p>If you load your image data using Image&#39;s <code>imread</code>, note that the storage order is not changed from the on-disk representation. Therefore, a 2D RGB image will most likely be stored in color-horizontal-vertical order, meaning that a pixel at <code>&#40;x,y&#41;</code> is accessed as <code>img&#91;x,y&#93;</code>. Note that this is quite different from Matlab&#39;s default representation.</p>
<p>If you are indexing over an extended region and want to get back an <code>Image</code>, rather than a value or an <code>Array</code>, then you will want to use <code>getindexim</code>, <code>subim</code>, and <code>sliceim</code>. For the first two, the resulting image will share everything but the <code>data</code> field with the original image; if you make modifications in one, the other will also be affected. For <code>sliceim</code>, because it can change the dimensionality some adjustments to <code>properties</code> are needed; in this case a copy is made.</p>
<p>One of the properties &#40;see below&#41; that you can grant to images is <code>spatialorder</code>, which provides a name for each spatial dimension in the image. Using this feature, you can cut out regions or slices from images in the following ways:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">A &#61; img&#91;&quot;x&quot;, 200:400, &quot;y&quot;, 500:700&#93;
imgs &#61; sliceim&#40;img, &quot;z&quot;, 14&#41;      # cuts out the 14th frame in a stack</code></pre>
<p>These routines &quot;do the right thing&quot; no matter what storage order is being used.</p>
<h1 id="image-properties-and-accessor-functions">Image properties and accessor functions</h1>
<p>The <code>properties</code> dictionary can contain any information you want to store along with your images. Typically, each property is also affiliated with an accessor function of the same name.</p>
<p>Let&#39;s illustrate this with one of the default properties, <code>&quot;colorspace&quot;</code>. The value of this property is a string, such as <code>&quot;RGB&quot;</code> or <code>&quot;Gray&quot;</code> or <code>&quot;HSV&quot;</code>. You can extract the value of this field using a function:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">cs &#61; colorspace&#40;img&#41;</code></pre>
<p>The reason to have a function, rather than just looking it up in the <code>properties</code> dictionary, is that we can provide defaults. For example, images represented as plain <code>Array</code>s don&#39;t have a <code>properties</code> dictionary; if we are to write generic code, we don&#39;t want to have to wonder whether this information is available. So for plain arrays, there are a number of defaults specified for the output of the <code>colorspace</code> function, depending on the element type and size of the array. Likewise, images stored as <code>Color</code> arrays have no need of a <code>&quot;colorspace&quot;</code> property, because the colorspace is encoded in the type parameters.</p>
<p>Here is a list of the properties supported in <code>core.jl</code>:</p>
<ul>
<li><code>colorspace</code>: &quot;RGB&quot;, &quot;RGBA&quot;, &quot;Gray&quot;, &quot;Binary&quot;, &quot;24bit&quot;, &quot;Lab&quot;, &quot;HSV&quot;, etc.  If   your image is represented as a Color array, you cannot override that   choice by specifying a <code>colorspace</code> property.  &#40;Use <code>reinterpret</code> if you want   to change the interpretation without changing the raw values.&#41;</li>
<li><code>colordim</code>: the array dimension used to store color information, or 0 if there   is no dimension corresponding to color</li>
<li><code>timedim</code>: the array dimension used for time &#40;i.e., sequence&#41;, or 0 for single   images</li>
<li><code>scalei</code>: a property that controls default contrast scaling upon display.   This should be a   <a href="function_reference.html#mapinfo"><code>MapInfo</code></a>   value, to be used for setting the contrast upon display. In the absence of   this property, the range 0 to 1 will be used.</li>
<li><code>pixelspacing</code>: the spacing between adjacent pixels along spatial dimensions</li>
<li><code>spacedirections</code>: more detailed information about the orientation of array   axes relative to an external coordinate system &#40;see the   <a href="function_reference.html">function reference</a>&#41;.</li>
<li><code>spatialorder</code>: a string naming each spatial dimension of the array, in the   storage order of the data array.  Names can be arbitrary, but the choices &quot;x&quot;   and &quot;y&quot; have special meaning &#40;horizontal and vertical, respectively,   irrespective of storage order&#41;.  If supplied, you must have one entry per   spatial dimension.</li>
</ul>
<p>If you specify their values in the <code>properties</code> dictionary, your values will be used; if not, hopefully-reasonable defaults will be chosen.</p>
<p>Naturally, you can add whatever additional properties you want: you could add the date/time at which the image was captured, the patient ID, etc. The main point of having a properties dictionary, rather than a type with fixed fields, is the flexibility of adding whatever metadata you find to be useful.</p>
<h1 id="writing-generic-algorithms">Writing generic algorithms</h1>
<p>Let&#39;s say you have an algorithm implemented for <code>Array</code>s, and you want to extend it to work on <code>Image</code> types. Let&#39;s consider the example of a hypothetical <code>imfilter</code>, written to perform kernel-based filtering in arbitrary dimensions. Let&#39;s say your <code>imfilter</code> looks like this:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">function imfilter&#123;T,N&#125;&#40;A::Array&#123;T,N&#125;, kernel::Array&#123;T,N&#125;, options...&#41;</code></pre>
<p>The first step might be to simply provide a version for <code>AbstractImage</code> types:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">function imfilter&#123;T,N&#125;&#40;img::AbstractImage&#123;T,N&#125;, kernel::Array&#123;T,N&#125;, options...&#41;
    out &#61; imfilter&#40;data&#40;img&#41;, kernel, options...&#41;
    shareproperties&#40;img, out&#41;
end</code></pre>
<p>Now let&#39;s say you additionally want to allow the user to filter color images–-where one dimension of the array is used to encode color–-with a filter of dimension <code>N-1</code> applied to each color channel separately. We can implement this version simultaneously for both <code>Image</code> types and other array types as follows:</p>
<pre><code class="language-&#123;.julia execute&#61;&quot;false&quot;&#125;">function imfilter&#123;T,N,N1&#125;&#40;img::AbstractArray&#123;T,N&#125;, kernel::Array&#123;T,N1&#125;, options...&#41;
    cd &#61; colordim&#40;img&#41;
    if N1 &#33;&#61; N - &#40;cd &#33;&#61; 0&#41;
        error&#40;&quot;kernel has the wrong dimensionality&quot;&#41;
    end
    out &#61; similar&#40;img&#41;
    for i &#61; size&#40;img, cd&#41;
        imsl &#61; img&#91;&quot;color&quot;, i&#93;
        outsl &#61; slice&#40;out, &quot;color&quot;, i&#41;
        copy&#33;&#40;outsl, imfilter&#40;imsl, kernel, options...&#41;&#41;
    end
    out
end</code></pre>
<p>There are other ways to achieve a similar effect; if you examine the actual implementation of <code>imfilter</code>, you&#39;ll see that the kernel is reshaped to be commensurate with the data array.</p>
<p>These solutions work no matter which dimension is used to store color, a feat that would be essentially impossible to achieve robustly in a generic algorithm if we didn&#39;t exploit metadata. Note also that if the user supplies an <code>Array</code>, s/he will get an <code>Array</code> back, and if using an <code>Image</code> will get an <code>Image</code> back with properties inherited from <code>img</code>.</p>
<p>Naturally, you can find other examples of generic implementations throughout the source code of <code>Images</code>.</p>

      <hr>
      </div>
      </div>

      <div class="col-sm-offset-8" style="z-index: 2">
        <div id="table-of-contents">
          <div id="table-of-contents-content">
            <input class="search" placeholder="SEARCH" />
            <ul class="toc list nav"><li>
    <a class="toc-item" href="index.html">Introduction</a>
</li>
<li>
    <a class="toc-item" href="aims.html">Aims</a>
</li>
<li>
    <a class="toc-item" href="install.html">Installation</a>
</li>
<li>
    <a class="toc-item toc-current-doc" href="core.html">Core Concepts</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#the-basic-types">The basic types</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#plain-arrays">Plain arrays</a>
</li>
<li>
    <a style="margin-left: 1.0em" class="toc-item" href="#image-types">Image types</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#addressing-image-data">Addressing image data</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#image-properties-and-accessor-functions">Image properties and accessor functions</a>
</li>
<li>
    <a style="margin-left: 0.5em" class="toc-item" href="#writing-generic-algorithms">Writing generic algorithms</a>
</li>
<li>
    <a class="toc-item" href="function_reference.html">Function Reference</a>
</li>
<li>
    <a class="toc-item" href="overlays.html">Overlays</a>
</li>
<li>
    <a class="toc-item" href="extendingIO.html">Extending IO</a>
</li>
<li>
    <a class="toc-item" href="status.html">Development Status</a>
</li>
</ul>

            <script>
                var toclist = new List("table-of-contents",
                                       {valueNames: ["toc-item"]})

                $("body").scrollspy({target: "#table-of-contents"});

                $("#table-of-contents li").on("activate.bs.scrollspy",
                    function(event) {
                        $("#table-of-contents ul").find("a").css({"font-weight": "normal"});
                        $(this).children("a").css({"font-weight": "bolder"});
                    });
            </script>
          </div>
        </div>
      </div>
    </div>

  <footer class="col-sm-8">
    <p class="muted">Last modified by Tim Holy on . Generated with
    <a href="https://github.com/dcjones/Judo.jl">Judo</a>.</p>
  </footer>

  </div>
</body>
</html>

